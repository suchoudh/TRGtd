/*
 * The contents of this file are subject to the terms of the Common Development
 * and Distribution License (the License). You may not use this file except in
 * compliance with the License.
 *
 * You can get a copy of the License at http://www.thinkingrock.com.au/cddl.html
 * or http://www.thinkingrock.com.au/cddl.txt.
 *
 * When distributing Covered Code, include this CDDL Header Notice in each file
 * and include the License file at http://www.thinkingrock.com.au/cddl.txt.
 * If applicable, add the following below the CDDL Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * "Portions Copyright [year] [name of copyright owner]"
 *
 * The Original Software is ThinkingRock. The Initial Developer of the Original
 * Software is Avente Pty Ltd, Australia.
 *
 * Portions Copyright 2006-2007 Avente Pty Ltd. All Rights Reserved.
 */
package tr.view.projects;

import java.awt.EventQueue;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Collections;
import java.util.logging.Logger;
import org.openide.nodes.Node;
import org.openide.util.HelpCtx;
import org.openide.util.Lookup;
import org.openide.util.NbBundle;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
import org.openide.windows.TopComponent;
import tr.model.Data;
import tr.model.DataLookup;
import tr.model.action.Action;
import tr.model.project.Project;
import tr.view.Window;
import tr.view.action.ActionPanel;
import tr.view.project.ProjectPanel;

/**
 * Top component window for the editing an action or a project.
 *
 * @author Jeremy Moore
 */
public final class EditorTopComponent extends Window implements Lookup.Provider {

    private static final Logger LOG = Logger.getLogger("tr.view.projects");
    private static final String PREFERRED_ID = "EditorTopComponent";
    private static EditorTopComponent instance;
    private final InstanceContent content = new InstanceContent();
    private final Lookup lookup = new AbstractLookup(content);
    private boolean initialised;
    private ActionPanel actionPanel;
    private ProjectPanel projectPanel;
    private Action viewAction;

    /* Constructs the instance. */
    private EditorTopComponent() {
        initComponents();
    }

    private void initialise() {
        if (initialised) {
            return;
        }
        Data data = (Data) DataLookup.instance().lookup(Data.class);
        if (data == null) {
            LOG.severe("Data model could not be found.");
            return;
        }

        projectPanel = new ProjectPanel();

        actionPanel = new ActionPanel();

        initialised = true;
    }

    @Override
    protected void componentOpened() {
        super.componentOpened();
        Data data = (Data) DataLookup.instance().lookup(Data.class);
        if (data != null) {
            view(data.getRootProjects());
        }
    }

    /**
     * Determines whether a given action is currently shown.
     * @param action The given action.
     * @return true if the given action is currently shown.
     */
    public boolean isViewing(Action action) {
        if (action == null) {
            return false;
        }
        if (actionPanel == null) {
            return false;
        }
        if (actionPanel != scrollPane.getViewport().getView()) {
            return false;
        }
        return action.equals(actionPanel.getModel());
    }

    /**
     * Determines whether a given project is currently shown.
     * @param action The given project.
     * @return true if the given project is currently shown.
     */
    public boolean isViewing(Project project) {
        if (project == null) {
            return false;
        }
        if (projectPanel == null) {
            return false;
        }
        if (projectPanel != scrollPane.getViewport().getView()) {
            return false;
        }
        return project.equals(projectPanel.getModel());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        emptyPanel = new javax.swing.JPanel();
        scrollPane = new javax.swing.JScrollPane();

        setLayout(new java.awt.BorderLayout());

        scrollPane.setBorder(null);
        add(scrollPane, java.awt.BorderLayout.CENTER);

    }// </editor-fold>//GEN-END:initComponents

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel emptyPanel;
    private javax.swing.JScrollPane scrollPane;
    // End of variables declaration//GEN-END:variables

    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link findInstance}.
     */
    public static synchronized EditorTopComponent getDefault() {
        if (instance == null) {
            instance = new EditorTopComponent();
            instance.initialise();
        }
        return instance;
    }

    /**
     * Obtain the instance. Never call {@link #getDefault} directly!
     */
    public static synchronized EditorTopComponent findInstance() {
//        TopComponent tc = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
//        if (tc == null) {
//            ErrorManager.getDefault().log(ErrorManager.WARNING, "Cannot find edit component. It will not be located properly in the window system.");
//            tc = getDefault();
//        }
//        if (!(tc instanceof EditorTopComponent)) {
//            ErrorManager.getDefault().log(ErrorManager.WARNING, "There seem to be multiple components with the '" + PREFERRED_ID + "' ID. That is a potential source of errors and unexpected behavior.");
//            tc = getDefault();
//        }
//        EditorTopComponent etc = (EditorTopComponent)tc;
//        etc.initialise();
//        return etc;
        return getDefault();
    }

    @Override
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_NEVER;
    }

//    /** Replaces this in object stream */
//    public Object writeReplace() {
//        return new ResolvableHelper();
//    }
    /** Gets the identifier. */
    @Override
    public String preferredID() {
        return PREFERRED_ID;
    }

//////    /**
//////     * Edit an action.
//////     * @param action The action to edit.
//////     */
//////    public void edit(Action action) {
//////        if (actionPanel == null) {
//////            return;
//////        }
//////
//////        requestActive();
//////
//////        view(action);
//////
//////        actionPanel.edit();
//////    }
    /**
     * Edit an action.
     * @param action The action to edit.
     */
    public void edit(ActionNode actionNode) {
        if (actionPanel == null) {
            return;
        }

        requestActive();

        view(actionNode);

        actionPanel.edit();
    }

//////    /**
//////     * Start editing a project.
//////     * @param project The project to edit.
//////     */
//////    public void edit(Project project) {
//////        if (projectPanel == null) {
//////            return;
//////        }
//////
//////        requestActive();
//////
//////        view(project);
//////
//////        projectPanel.edit();
//////    }
    /**
     * Start editing a project.
     * @param project The project to edit.
     */
    public void edit(ProjectNode projectNode) {
        if (projectPanel == null) {
            return;
        }

        requestActive();

        view(projectNode);

        projectPanel.edit();
    }

    /**
     * View an action node.
     * @param action The action node to view.
     */
    public void view(Node node) {
        if (node instanceof ActionNode) {
            ActionNode actionNode = (ActionNode) node;
            view(actionNode.action);
            content.set(Collections.singleton(actionNode), null);
        }
        if (node instanceof ProjectNode) {
            ProjectNode projectNode = (ProjectNode) node;
            view(projectNode.project);
            content.set(Collections.singleton(projectNode), null);
        }
    }

    /**
     * View a project.
     * @param project The project to view.
     */
    private void view(Project project) {
        assert (project != null);

        if (!isOpened()) {
            return;
        }
        if (isViewing(project)) {
            return;
        }
        
        // stop listening to last viewed action
        if (viewAction != null) {
            viewAction.removePropertyChangeListenter(Action.PROP_STATE, actionStateListener);
        }         
        viewAction = null;

        
        synchronized (this) {
            setName(NbBundle.getMessage(getClass(), "CTL_ProjectTopComponent"));
            setToolTipText(NbBundle.getMessage(getClass(), "TTT_ProjectTopComponent"));
            setIcon(project.getIcon(false).getImage());
            if (project.isEditable()) {
                projectPanel.initModel(project);
                scrollPane.setViewportView(projectPanel);
            } else {
                setName(project.getDescription());
                scrollPane.setViewportView(emptyPanel);
            }
            revalidate();
            repaint();
//////            ItemLookup.instance().setCurrent(project);
        }
    }

    /**
     * View an action.
     * @param action The action to view.
     */
    private void view(final Action action) {
        if (!isOpened()) {
            return;
        }
        if (isViewing(action)) {
            return;
        }

        if (viewAction != null) {
            viewAction.removePropertyChangeListenter(Action.PROP_STATE, actionStateListener);
        }         
        viewAction = action;
        
        action.addPropertyChangeListenter(Action.PROP_STATE, actionStateListener);
        
        synchronized (this) {
            setName(NbBundle.getMessage(getClass(), "CTL_ActionTopComponent"));
            setToolTipText(NbBundle.getMessage(getClass(), "TTT_ActionTopComponent"));
            setIcon(action.getIcon(false).getImage());
            if (action != null && action.isEditable()) {
                actionPanel.initModel(action);
                scrollPane.setViewportView(actionPanel);
            } else {
                scrollPane.setViewportView(emptyPanel);
            }
            revalidate();
            repaint();
//////            ItemLookup.instance().setCurrent(action);
        }
    }

    private void refreshIcon(final Action action) {
        if (action != null) {
            EventQueue.invokeLater(new Runnable() {
                public void run() {
                    setIcon(action.getIcon(false).getImage());            
                }                
            });
        }
    }
    
    private final PropertyChangeListener actionStateListener =
            new PropertyChangeListener() {
                public void propertyChange(PropertyChangeEvent evt) {
                    if (evt.getSource() instanceof Action) {
                        refreshIcon((Action) evt.getSource());
                    }
                }
            };

//    final static class ResolvableHelper implements Serializable {
//        private static final long serialVersionUID = 1L;
//        public Object readResolve() {
//            return EditorTopComponent.getDefault();
//        }
//    }
    @Override
    public HelpCtx getHelpCtx() {
        return new HelpCtx("tr.view.projects");
    }

    @Override
    public Lookup getLookup() {
        return lookup;
    }

    @Override
    public void takeFocus() {
        ActionNode actionNode = (ActionNode) lookup.lookup(ActionNode.class);
        if (actionNode != null) {
            actionPanel.requestFocusInWindow();

        } else {
            ProjectNode projectNode = (ProjectNode) lookup.lookup(ProjectNode.class);
            if (projectNode != null) {
                projectPanel.requestFocusInWindow();
            }
        }
    }
}
